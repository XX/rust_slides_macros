<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Макросы в Rust</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown>
                    <textarea data-template>
                        # Rust
                        # Макросы

                        Могучие, удобные и в меру безопасные средства метапрограммирования в [Rust](https://rust-lang.org).
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ## Зачем нужны макросы?
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### 1. Расширение синтаксиса
                        
                        ```rust
                        let nums = {
                            let mut tmp = Vec::new();
                            tmp.push(1);
                            tmp.push(2);
                            tmp.push(3);
                            tmp
                        };
                        ```
                        
                        ```rust
                        let nums = vec![1, 2, 3];
                        let v = vec![42; 3];
                        ```
                        
                        Note:
                        vec! использует интаксическое сокращение для любого количества параметров.
                        
                        Макросы позволяют абстрагироваться на синтаксическом уровне. Вызов макроса является сокращением для «расширенной» синтаксической формы. Это расширение происходит в начале компиляции, до начала статической проверки.
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### 2. Обкатка улучшений языка
                        
                        `try!`
                        
                        ```rust
                        let mut file = try!(File::create("file.txt"));
                        ```
                        
                        `?`
                        
                        ```rust
                        let mut file = File::create("file.txt")?;
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### 3. Использование DSL
                        
                        SQL
                        
                        ```rust
                        let sql = sql!(SELECT * FROM posts WHERE id=1);
                        ```
                        
                        JSON
                        
                        ```rust
                        let value = json!({
                            "code": 200,
                            "success": true,
                            "payload": {
                                "features": [
                                    "serde",
                                    "json"
                                ]
                            }
                        });
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### 4. Зависимая кодогенерация
                        
                        Автореализация `Debug`
                        
                        ```rust
                        #[derive(Debug)]
                        struct Point {
                            x: i32,
                            y: i32,
                        }
                        ```
                        
                        Сгенерирует
                        
                        ```rust
                        impl Debug for Point {
                            fn fmt(&self, f: &mut Formatter) -> Result {
                                write!(f, "Point {{ x: {}, y: {} }}", self.x, self.y)
                            }
                        }
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### 5. Оптимизация исполнения читаемого кода
                        
                        Использование `vec!`
                        
                        ```rust
                        let nums = vec![1, 2, 3];
                        ```
                        
                        Сгенерирует
                        
                        ```rust
                        let nums = <[_]>::into_vec(Box::new([1, 2, 3]));
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Какие бывают макросы?

                        - [Декларативные](https://doc.rust-lang.org/book/2018-edition/appendix-04-macros.html) (обычные, образцовые)
                        ```rust
                        foo!(..) // {}, []
                        ```
                        - [Процедурные](https://doc.rust-lang.org/reference/procedural-macros.html)
                        ```rust
                        foo!(..) // {}, []
                        ```
                        ```rust
                        #[derive(Foo)]
                        ```
                        ```rust
                        #[foo]
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ## Декларативные макросы
                    </textarea>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Макрос `vec`

                        Определение:
                        ```rust
                        macro_rules! vec {
                            ($elem:expr; $n:expr) => (
                                $crate::vec::from_elem($elem, $n)
                            );
                            ($($x:expr),*) => (
                                <[_]>::into_vec(box [$($x),*])
                            );
                            ($($x:expr,)*) => (vec![$($x),*])
                        }
                        ```
                        
                        Note:
                        Макрос определяется с помощью ряда правил, которые представляют собой варианты сопоставления с образцом.
                        Сопоставление происходит на уровне синтаксических деревьев Rust, на этапе компиляции.
                        
                        Образец $x:expr будет соответствовать любому выражению Rust, связывая его дерево синтаксиса с метапеременной $x. Идентификатор expr является спецификатором фрагмента.
                        
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Обнаружитель совпадений (matcher)
                        
                        `$`*name*`:`*designator*
                        <small>
                        - **`item`** - [элемент](https://doc.rust-lang.org/stable/reference/items.html)
                        - **`block`** - [блок](https://doc.rust-lang.org/stable/reference/expressions/block-expr.html)
                        - **`stmt`** - [оператор](https://doc.rust-lang.org/stable/reference/statements.html)
                        - **`pat`** - [образец](https://doc.rust-lang.org/stable/reference/expressions/match-expr.html)
                        - **`expr`** - [выражение](https://doc.rust-lang.org/stable/reference/expressions.html)
                        - **`ty`** - [тип](https://doc.rust-lang.org/stable/reference/types.html)
                        - **`ident`** - [идентификатор](https://doc.rust-lang.org/stable/reference/identifiers.html) или [ключевое слово](https://doc.rust-lang.org/stable/reference/keywords.html)
                        - **`path`** - [путь](https://doc.rust-lang.org/stable/reference/paths.html)
                        - **`tt`** - [дерево токенов](https://doc.rust-lang.org/stable/reference/tokens.html)
                        - **`meta`** - содержимое [атрибута](https://doc.rust-lang.org/stable/reference/attributes.html)
                        - **`lifetime`** - [время жизни](https://doc.rust-lang.org/stable/reference/tokens.html#lifetimes-and-loop-labels)
                        - **`vis`** - [спецификатор видимости](https://doc.rust-lang.org/stable/reference/visibility-and-privacy.html)
                        
                        </small>
                        
                        Note:
                        $name - метапеременная
                        :designator - спецификатор фрагмента
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### В Rust макросы гигиеничны
                        
                        Проблемы макросов C
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        ```C
                        #define MUL(x) (x * 5)

                        MUL(2 + 8); // (2 + 8 * 5) -> 42 ??
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        Отсутствуют в Rust
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                        ```Rust
                        macro_rules! mul {
                            ($x:expr) => { $x * 5 };
                        }
                        
                        mul!(2 + 8); // { (2 + 8) * 5 } -> 50 !!
                        ```
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                        
                        Note:
                        Некоторые языки реализуют макросы с помощью простой текстовой замены, что приводит к проблемам.
                        
                        Метапеременная $x обрабатывается как единый узел с выражением, и сохраняет свое место в синтаксическом дереве даже после замены.
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Нет захвата переменных
                        
                        <sub>Макрос раскрывается в отдельном контексте синтаксиса</sub>
                        ```Rust
                        macro_rules! foo {
                            ($v:ident) => (let $v = 3);
                        }

                        fn main() {
                            foo!(x);
                            println!("{}", x);
                        }
                        ```
                        <sub>Только для связываний `let` и меток `loop`, но не для [элементов](https://doc.rust-lang.org/stable/reference/items.html)</sub>
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section>
                    <h3>Что принимает макрос?</h3>
                    <sub>Единственное нелистовое дерево токенов</sub>
                    <br/>
                    
                    <sub class="fragment" data-fragment-index="1">Последовательность токенов:</sub>
                    <pre class="fragment" data-fragment-index="1"><code data-trim contenteditable>
                    a + b + (c + d[0]) + e
                    </code></pre>
                    
                    <sub class="fragment" data-fragment-index="2">Представляется следующим деревом токенов:</sub>
                    <pre class="fragment" data-fragment-index="2"><code class="hljs" data-trim contenteditable>
                    «a» «+» «b» «+» «(   )» «+» «e»
                              ╭────────┴──────────╮
                               «c» «+» «d» «[   ]»
                                            ╭─┴─╮
                                             «0»
                    </code></pre>
                    
                    <sub class="fragment" data-fragment-index="3"><sub><i>токены, заключенные в <code>(..)</code>, <code>[..]</code> или <code>{..}</code></i></sub></sub>
                    <pre class="fragment" data-fragment-index="3"><code class="hlrs" data-trim contenteditable>
                    mac!(..), mac![..], mac!{..}
                    </code></pre>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Во что разворачивается макрос?
                        
                        - Выражение
                        - Образец
                        - Ноль или больше элементов
                        - Ноль или больше `impl`-элементов
                        - Оператор
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Привет, макрос!

                        ```rust
                        fn main() {
                            println!("Hello World!");
                        }
                        ```
                        Макрос форматированного вывода: <!-- .element: class="fragment" data-fragment-index="1" -->
                        ```rust
                        println!("Arg a is {}, b is {}", a, b);
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        Другие популярные макросы:  <!-- .element: class="fragment" data-fragment-index="2" -->
                        ```
                        format!(..), try!(..), vec!(..), assert!(..), assert_eq!(..),
                        panic!(..), unreachable!(), unimplemented!()
                        ```
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Получение форматированной строки

                        <small>`println!` -> `print!` -> `format_args!`</small>

                        <small>`format!` -> `format_args!`</small>
                        
                        ```rust
                        fn main() {
                            let s = format!("Hello {}!", "World");
                            println!("{}", s);
                        }
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Получение форматированной строки

                        ```rust
                        format!("Hello");                 // "Hello"
                        format!("Hello, {}!", "world");   // "Hello, world!"
                        format!("The number is {}", 1);   // "The number is 1"
                        format!("{:?}", (3, 4));          // "(3, 4)"
                        format!("{value}", value = 4);    // "4"
                        format!("{} {}", 1, 2);           // "1 2"
                        format!("{:04}", 42);             // "0042"

                        format!("{argument}", argument = "test");   // "test"
                        format!("{name} {}", 1, name = 2);          // "2 1"
                        format!("{a} {c} {b}", a="a", b='b', c=3);  // "a 3 b"
                        ```
                        
                        <small>`{} - Display`<br/>`{:?} - Debug`</small> <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ## Эволюция макроса `try`
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Без `try` в Rust шумно

                        ```rust
                        fn write_text() -> Result<(), MyError> {
                            let mut file = match File::create("file.txt") {
                                Ok(f) => f,
                                Err(e) => return Err(From::from(e)),
                            };
                            
                            match file.write_all(b"Some text.") {
                                Ok(v) => v,
                                Err(e) => return Err(From::from(e)),
                            }
                            Ok(())
                        }
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### С макросом `try`

                        ```rust
                        fn write_text() -> Result<(), MyError> {
                            let mut file = try!(File::create("file.txt"));
                            try!(file.write_all(b"Some text."));
                            Ok(())
                        }
                        ```
                        
                        ### С оператором `?`
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        
                        ```rust
                        fn write_text() -> Result<(), MyError> {
                            let mut file = File::create("file.txt")?;
                            file.write_all(b"Some text.")?;
                            Ok(())
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        
                        ```Rust
                        fn write_text() -> Result<(), MyError> {
                            File::create("file.txt")?.write_all(b"Some text.")?;
                            Ok(())
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Определение `try` в `std`

                        ```rust
                        macro_rules! try {
                            ($expr:expr) => (match $expr {
                                $crate::result::Result::Ok(val) => val,
                                $crate::result::Result::Err(err) => {
                                    return $crate::result::Result::Err(
                                        $crate::convert::From::from(err)
                                    )
                                }
                            });
                            ($expr:expr,) => (try!($expr));
                        }
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Макросы утверждений
                        
                        ```rust
                        macro_rules! assert {
                            ($cond:expr) => ({ /* compiler built-in */ });
                            ($cond:expr,) => ({ /* compiler built-in */ });
                            ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });
                        }
                        ```

                        ```rust
                        #[test]
                        fn it_works() {
                            let x = true;
                            assert!(x);
                            assert!(x, "x wasn't true!");
                            assert_eq!(2 + 2, 4);
                        }
                        
                        #[test]
                        fn it_not_works() {
                            let vec = vec![1];
                            assert!(vec.is_empty());
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section>
                    <h3>Макросы утверждений</h3>
                        <pre><code data-trim contenteditable>
                        running 2 tests
                        test it_works ... ok
                        test it_not_works ... FAILED

                        failures:

                        ---- it_not_works stdout ----
                        thread 'it_not_works' panicked at 'assertion failed:
                          vec.is_empty()', src/lib.rs:13:5
                        note: Run with `RUST_BACKTRACE=1` for a backtrace.


                        failures:
                            it_not_works

                        test result: FAILED. 1 passed; 1 failed;
                          0 ignored; 0 measured; 0 filtered out
                        </code></pre>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ## DSL на макросах
                    </textarea>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Макрос `serde_json::json`

                        ```rust
                        let value = json!({
                            "code": 200,
                            "success": true,
                            "payload": {
                                "features": [
                                    "serde",
                                    "json"
                                ]
                            }
                        });
                        ```
                        <small>Конструирует значение типа **`serde_json::Value`** из JSON-литерала.</small>
                        
                        [Определение макроса **`json`**](https://docs.serde.rs/src/serde_json/macros.rs.html#70-75)
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        
                        ```rust
                        macro_rules! json {
                            ($($json:tt)+) => { ... };
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Макрос **`assemble6502`**

                        ```rust
                        let machine_code = assemble6502! {
                        init:
                            // Init regs and stack
                            lda #0
                            ldx #0xff
                            txs
                            ldx #0
                            ldy #0
                            // Do some demo-math
                            adc #0          // Immediate
                            adc 0x12, x     // Zero Page indexed with X
                            adc 0x34        // Zero Page
                            adc abs 0x1234  // Absolute (0x1234)
                            adc abs 0x3040, y   // Abs. indexed with Y
                            adc (0x10, x)   // (Indirect, X)
                            adc (0x01),y    // (Indirect),Y
                            
                            lda #0
                        addloop:
                            adc #1
                            bne addloop
                        main:
                            jmp main
                        };
                        ```
                        <small>Создает массив байтов с машинными кодами.</small>
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### JSX-подобные шаблоны в **`yew`**

                        ```html
                        html! {
                            <section class="todoapp",>
                                <header class="header",>
                                    <h1>{ "todos" }</h1>
                                    { view_input(&model) }
                                </header>
                                <section class="main",>
                                    <input class="toggle-all", type="checkbox",
                                        checked=model.is_all_completed(),
                                        onclick=|_| Msg::ToggleAll, />
                                    { view_entries(&model) }
                                </section>
                            </section>
                        }
                        ```
                        <small>Конструирует значение типа **`yew::Html<Model>`**.</small>
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Правила следования
                        
                        - За [`expr`](https://doc.rust-lang.org/stable/reference/expressions.html) и [`stmt`](https://doc.rust-lang.org/stable/reference/statements.html) может следовать **`=> , ;`**
                        - За [`pat`](https://doc.rust-lang.org/stable/reference/expressions/match-expr.html) может следовать **`=> , | = if in`**
                        - За [`ty`](https://doc.rust-lang.org/stable/reference/types.html) и [`path`](https://doc.rust-lang.org/stable/reference/paths.html) может следовать **`=> , = | ; : > [ { as where`**
                        - За другими может следовать любой токен
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Проблемы декларативных макросов
                        
                        1. Они декларативны
                        2. Имеют собственный язык, трудночитаемый
                        3. Невозможны сложные преобразования
                        4. Ограничен стек рекурсии
                        5. Тело всегда помещается внутрь скобок
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ## Процедурные макросы
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Почему процедурные?

                        <br/>
                        Входной **`TokenStream`**
                        
                        ↓
                        
                        Процедура преобразований на Rust
                        
                        ↓
                        
                        Выходной **`TokenStream`**
                    </textarea>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ### Виды процедурных макросов

                        - Функциональные макросы
                        ```rust
                        custom!(...)
                        ```
                        - `Derive`-макросы
                        ```rust
                        #[derive(CustomMode)]
                        ```
                        - Атрибутные макросы
                        ```rust
                        #[custom_attribute]
                        ```
                    </textarea>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Функциональные макросы

                        Как декларативные, только мощнее:
                        ```rust
                        let year = rn!(MMXVIII);
                        ```
                        <small>Но не гигиеничны!</small>
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        
                        Определение:
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                        ```rust
                        [lib]
                        proc-macro = true
                        ```
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                        ```rust
                        #[proc_macro]
                        pub fn rn(input: TokenStream) -> TokenStream {
                            ...
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                    </script>
                </section>
                
                <section>
                    <h3>Реализация <code><strong>rn</strong></code></h3>
                        <pre><code class="hlrs" data-trim contenteditable>
                        extern crate proc_macro;
                        extern crate syn;

                        use proc_macro::{TokenStream, TokenTree, Literal};
                        use syn::{Ident};

                        static NUMERALS: &'static [(&'static str, u32)] = &[
                            ("M", 1000), ("CM", 900), ("D", 500), ("CD", 400),
                            ("C",  100), ("XC",  90), ("L",  50), ("XL",  40),
                            ("X",   10), ("IX",   9), ("V",   5), ("IV",   4),
                            ("I",    1)
                        ];

                        #[proc_macro]
                        pub fn rn(input: TokenStream) -> TokenStream {
                            let rn_string = syn::parse::&lt;Ident>(input)
                                .unwrap().to_string();
                            
                            let mut rn_str = rn_string.as_str();
                            let mut total = 0;
                            while !rn_str.is_empty() {
                                match NUMERALS.iter()
                                        .find(|&(rn, _)| rn_str.starts_with(rn)) {
                                    Some((rn, val)) => {
                                        total += val;
                                        rn_str = &rn_str[rn.len()..];
                                    },
                                    None => panic!("Unknown roman numeral"),
                                }
                            }
                            TokenTree::from(
                                Literal::u32_suffixed(total)
                            ).into()
                        }
                        </code></pre>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Использование **`rn`**

                        Только в `nightly` :(
                        ```rust
                        #![feature(proc_macro_hygiene)]
                        
                        extern crate roman_numerals;

                        use roman_numerals::rn;

                        fn main() {
                            assert_eq!(rn!(MMXVIII), 2018);
                        }
                        ```
                        Но есть
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        [proc-macro-hack](https://github.com/dtolnay/proc-macro-hack) !)
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### `Derive`-макросы

                        ```rust
                        #[derive(Serialize, Deserialize, Debug, PartialEq)]
                        struct Pet {
                            name: String,
                            
                            #[serde(rename = "a")]
                            age: i32,
                        }
                        ```
                        
                        Определение:
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        ```rust
                        #[proc_macro_derive(Serialize, attributes(serde))]
                        pub fn derive_serialize(input: TokenStream) -> TokenStream {
                            ...
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### `Derive`-макросы

                        ```rust
                        #[derive(Parser)]
                        #[grammar = "ident.pest"]
                        struct IdentParser;
                        ```
                        
                        ```
                        alpha = { 'a'..'z' | 'A'..'Z' }
                        digit = { '0'..'9' }
                        ident = { (alpha | digit)+ }
                        ident_list = _{ !digit ~ ident ~ (" " ~ ident)+ }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        
                        Определение:
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                        ```rust
                        #[proc_macro_derive(Parser, attributes(grammar))]
                        pub fn derive_parser(input: TokenStream) -> TokenStream {
                            ...
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="2" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Использование [`VariantCount`](https://github.com/XX/variant_count)

                        ```rust
                        extern crate variant_count;

                        use variant_count::VariantCount;

                        #[derive(VariantCount)]
                        enum Test {
                            First(i32),
                            Second(Option<String>),
                            Third,
                        }
                        
                        ...
                        assert_eq!(Test::VARIANT_COUNT, 3);
                        ```
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Реализация [`VariantCount`](https://github.com/XX/variant_count)

                        ```rust
                        extern crate proc_macro;
                        extern crate syn;
                        extern crate quote;

                        use proc_macro::TokenStream;
                        use syn::DeriveInput;
                        use quote::quote;

                        #[proc_macro_derive(VariantCount)]
                        pub fn variant_count(input: TokenStream) -> TokenStream {
                            let ast: DeriveInput = syn::parse(input).unwrap();
                            let (vis, ty, generics) = (&ast.vis, &ast.ident, &ast.generics);
                            let variants = match &ast.data {
                                syn::Data::Enum(e) => &e.variants,
                                _ => panic!("VariantCount can only be derived for enums"),
                            };
                            let count = variants.len();
                            let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

                            let tokens = quote! {
                                impl #impl_generics #ty #ty_generics
                                    #where_clause
                                {
                                    #vis const VARIANT_COUNT: usize = #count;
                                }
                            };
                            tokens.into()
                        }
                        ```
                    </script>
                </section>
                
                <section data-markdown>
                    <script type="text/template">
                        ### Атрибутные макросы

                        ```rust
                        #[route(GET, "/")]
                        fn index(request: Request) -> Response {
                            ...
                        }
                        ```
                        
                        Определение:
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                        ```rust
                        #[proc_macro_attribute]
                        pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
                            ...
                        }
                        ```
                        <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
                </section>
                
                <section data-markdown>
                    <textarea data-template>
                        ## И это все?

                        #### Остальное - в ответах на вопросы :)
                    </textarea>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
